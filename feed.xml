<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="https://urbanistas.lt/feed.xml" rel="self" type="application/atom+xml" /><link href="https://urbanistas.lt/" rel="alternate" type="text/html" /><updated>2018-07-17T19:09:39+00:00</updated><id>https://urbanistas.lt/</id><title type="html">Urbanistas</title><subtitle>Blogas apie žmones, idėjas ir technologijas, kurios keičia miesto aplinką.
</subtitle><entry><title type="html">Kodėl vaikai Japonijoje labai anksti tampa nepriklausomais? 🇯🇵</title><link href="https://urbanistas.lt/supratimas/2018/05/20/vaikai-japonijoje.html" rel="alternate" type="text/html" title="Kodėl vaikai Japonijoje labai anksti tampa nepriklausomais? 🇯🇵" /><published>2018-05-20T05:10:00+00:00</published><updated>2018-05-20T05:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2018/05/20/vaikai-japonijoje</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2018/05/20/vaikai-japonijoje.html">&lt;p&gt;&lt;strong&gt;Japonijoje maži vaikai važinėja metro ir keliauja mieste be tėvų priežiūros.
Tokio laisvo judėjimo priežastis mieste yra susijusi labiau su socialiniu patikimumu negu asmenine nepriklausomybe.&lt;/strong&gt;
&lt;img alt=&quot;Vaikas Tokijo metro&quot; src=&quot;/assets/japan_kids/940-1d07b7df4f1cf49b28c865db8643818736b792b563a284366ea5c651c8c8afa4.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter x--pt smaller&quot;&gt;
    Moksleivė eina viename iš Tokijo metro perėjimų / Nuotrauka: Reuters
&lt;/div&gt;

&lt;p&gt;Keliaujantys vaikai be saugusiųjų priežiūros tai normali situacija Tokijuje. Tėvai dažnai paleidžia vaikus į pasaulį
ankstyvam amžiuje. Populiari TV laida &lt;a href=&quot;//reddit.com/r/raisingkids/comments/166in4/hajimete_no_otsukai_first_errand_is_a_japanese_tv/&quot;&gt;&lt;em&gt;Hajimete no Otsukai&lt;/em&gt;&lt;/a&gt; arba &lt;em&gt;Mano pirmasis pavedimas&lt;/em&gt;
kuri buvo transliuojama 25 metus, rodo dviejų-trijų metų vaikus kurie atlikinėja tėvų nurodytą užduotį, pavyzdžiui eina apsipirkti, kai tuo metu juos filmuoja paslėpta kamera.&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
    &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/e5k5XTZy0rA&quot; frameborder=&quot;0&quot; allow=&quot;autoplay; encrypted-media&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;Kas nulemia tokį neįprastą nepriklausomybės lygį?
Pasirodo tai ne savarankiškumas, bet “pasitikėjimas grupe”, pasak Dvaine Dikson (Dwayne Dixon), 
kultūros antropologė kurį parašė &lt;a href=&quot;//scalar.usc.edu/students/endlessquestion/index&quot;&gt;disertaciją&lt;/a&gt; apie Japonijos vaikus. 
“[Japonijos] vaikai mokosi tuo labai anksti, idealiausiai, kad kiekvienas bendruomenės narys galėtų būti 
kviečiamas tarnauti arba padėti kitiems”, — pabrėžė ji.&lt;/p&gt;

&lt;p&gt;Tokia praktika realizuojama ir mokykloje, kur vaikai atlieka valymo ir serviravimo darbus pietų metu, 
vietoje suaugusiųjų kurie dažniausiai atlieka šias pareigas. “Tai padeda patirti kitų žmonių darbo našumą ir 
keičia kasdienines pareigas, tai pat padeda patirti tai koks yra sudėtingas darbas, pavyzdžiui, tualeto valymas”, — sako Dikson.&lt;/p&gt;

&lt;p&gt;Priimant atsakomybę už bendras erdves įtakoja tam, jog pas vaikus atsiranda nuosavybės pojūtis, jie pradeda
suprasti materialias pasekmes dėl betvarkės atsiradimo, nes tuo atveju jiems reikės valyti tai.
Ši kultūra pereina ir į viešąsias erdves (viena iš priežasčių kodėl gatvės Japonijoje labai švarios).
Vaikas visuomenėje žino, jog gali pasikliauti grupe kurį pagelbės nelaimės atveju.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Vaikas važiuoja Tokijo metro&quot; src=&quot;/assets/japan_kids/b12ae721b-d91b307237ed9d7c297e0d8aa947025dd57f7d0249f157a36f04bbbe88f57eb8.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter x--pt smaller&quot;&gt;
    Maža mergaitė naudojasi Tokijo metro viena / Flickr
&lt;/div&gt;

&lt;p&gt;Japonija turi labai žemą nusikalstamumo lygį, tai leidžia mažiau jaudintis tėvams kurie išleidžia savo 
atžalas į miestą. Tačiau nedidelio mąsto miesto erdvės ir vaikščiojimo bei viešojo transporto naudojimo 
kultūra taip pat daro įtaką saugumui, taip pat labai svarbiam aspektui — &lt;strong&gt;saugumo suvokimui&lt;/strong&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&quot;Viešoji erdvė puikiai sumažinta ir pritaikyta žmonėms, ji taip pat 
valdo srautą ir lėtina eismo greitį&quot;, — pabrėžia Dikson. Japonijos miestuose žmonės yra įpratę
vaikščioti visur, o viešasis transportas vyrauja automobilių kultūrą. Tokijuje
pusė visų kelionių vyksta geležinkeliu ar autobusu, o ketvirtis - pėsčiomis.
Vairuotojai pratinami dalintis keliu ir nusileisti pėstiesiems bei dviratininkams.
&lt;/blockquote&gt;

&lt;p&gt;Suteikdami jiems tokią laisvę, tėvai didelį pasitikėjimą teikia ne tik savo vaikams,
bet ir visai bendruomenei. “Daugybė vaikų visame pasaulyje yra savarankiški”, pastebi antropologė.
“Tačiau tai kuo vakariečiai yra suintriguoti [Japonijoje] — tai pasitikėjimo ir 
bendradarbiavimo ryšys, kuris įvyksta dažnai neišsakytas arba nepageidaujamas”.&lt;/p&gt;</content><author><name></name></author><summary type="html">Japonijoje maži vaikai važinėja metro ir keliauja mieste be tėvų priežiūros. Tokio laisvo judėjimo priežastis mieste yra susijusi labiau su socialiniu patikimumu negu asmenine nepriklausomybe. Moksleivė eina viename iš Tokijo metro perėjimų / Nuotrauka: Reuters</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/japan_kids/940.jpg" /></entry><entry><title type="html">Kodėl koriai neišgelbės Vilniaus 🐝</title><link href="https://urbanistas.lt/supratimas/2018/04/19/kodel-koriukai-neisgelbes-vilniaus.html" rel="alternate" type="text/html" title="Kodėl koriai neišgelbės Vilniaus 🐝" /><published>2018-04-19T15:10:00+00:00</published><updated>2018-04-19T15:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2018/04/19/kodel-koriukai-neisgelbes-vilniaus</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2018/04/19/kodel-koriukai-neisgelbes-vilniaus.html">&lt;h2 id=&quot;keturi-ratai-ant-žalios-vejos&quot;&gt;Keturi ratai ant žalios vejos&lt;/h2&gt;

&lt;p&gt;Atrodo, gera idėja įrengti parkavimo vietas prie namų — civilizuotai padengiant veją arba tai kas nuo jos liko koriais. Ir automobilių vairuotojams gerai, turėti galimybę be gresmės gauti KET baudą po langais palikti savo automobilį ir pastovus &lt;a href=&quot;https://tvarkaumiesta.lt&quot;&gt;tvarkaumiesta.lt&lt;/a&gt; vartotojai nefiksuoja pažeidimus.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Korių įrengimas Vilniuje&quot; src=&quot;/assets/koriai-2-4b54bc2cdf40369fcb841da996d8b4d9a983a78062426cf7800c5a89411e34de.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter x--pt&quot;&gt;
    Nuotrauka Sauliaus Žiūros
&lt;/div&gt;

&lt;p&gt;Dūstantis nuo automobilių Vilnius maloniai pakvies nemokamai priparkuoti savo keturratį draugą šalia laiptinės — taip skatinant savo kasdieninėms kelionėms pasirinkti nuosavą automobilį, o kiti infrastruktūros pakeitimai tokie kaip požeminių perėjų/viadukų įrengimas, aplinkeliai, eismo juostų didinimas padės miestiečiui judėti dar laisviau.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Korių įrengimas Vilniuje&quot; src=&quot;/assets/koriai-4-8e42a362a11f5d38775eab5523735bb50efd70a75f57dc06001aacbcc7a76a2a.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter x--pt&quot;&gt;
    Kamščiai Vilniaus mieste, nuotrauka delfi.lt
&lt;/div&gt;

&lt;p&gt;Bet ta laisvė labai greitai baigsis ir pasipiktinę vairuotojai vėl prašys didesnių investicijų infrastruktūrai — dar daugiau juostų, užkąsti po žeme pėsčiuosius ir sukišti į asfaltą mokesčių mokėtojų pinigus. Užburtas ratas kuriame neišvengiamai sostinė kapituliuos prieš dviratį ir viešąjį transportą, bet prieš tai reikia užminti ant tų pačių grėblių kaip ir Vakarų Europos šalys prieš 40 metų.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Kamštis Amsterdame&quot; src=&quot;/assets/koriai-amsterdamas-25f9875e8df0df7ded871ae59e3423d0d49862998536d2a8d68b030d59110cd3.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter x--pt&quot;&gt;
    Kamščiai Amsterdame, 1970 metai
&lt;/div&gt;</content><author><name></name></author><summary type="html">Keturi ratai ant žalios vejos</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/koriai.jpg" /></entry><entry><title type="html">Nedidelio mąsto intervencijos Vankuveryje - kaip jie įtakoja žmonių jausmus ir elgesį?</title><link href="https://urbanistas.lt/erdves/2017/12/17/Nedidelio-masto-intervencijos.html" rel="alternate" type="text/html" title="Nedidelio mąsto intervencijos Vankuveryje - kaip jie įtakoja žmonių jausmus ir elgesį?" /><published>2017-12-17T08:10:00+00:00</published><updated>2017-12-17T08:10:00+00:00</updated><id>https://urbanistas.lt/erdves/2017/12/17/Nedidelio-masto-intervencijos</id><content type="html" xml:base="https://urbanistas.lt/erdves/2017/12/17/Nedidelio-masto-intervencijos.html">&lt;p&gt;Šis klausimas įkvėpė &lt;a href=&quot;//thehappycity.com/&quot;&gt;“Happy City”&lt;/a&gt; įgyvendinti eksperimentą Vankuveryje (Kanada) kuris
parodytų kaip spalvingos ir nekasdieninės intervencijos gali įtakoti žmonių gerbūvį.
Pagrindinė eksperimento idėja buvo suprasti, kaip miesto dizainas gali veikti žmonių
pasitikėjimo jausmą nepažįstamiems, jų emocijas. Eksperimento dalyviai praėjo per
trys populiariausias vietas kuriomis kasdien keliauja miesto gyventojai - takas 
tarp gyvenamųjų namų, sankryžą, bei tvarkingą žaliąją erdvę. Dalyviai aplankė
trys tas pačias vietas kur buvo atlikti pakeitimai.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Sankryžos Vankuveryje&quot; src=&quot;/assets/vancuver-interventions/Intersections-3b4c6d96837c2a30badaf83c410f18872eb512aaba6d31b76bf84c59bcafc833.png&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter x--pt&quot;&gt;
    Kūrybiškai nuspalvintos sankryžos suteikia pasitikėjimo ir saugumo jausmą.
&lt;/div&gt;

&lt;p&gt;Eksperimento rezultatai parodė, jog miestai gali gerinti gerbūvį ir pasitikėjimą
intervenciju pagalba, kurios įterpia gamtą, spalvas ir unikalius elementus 
viešojoje erdvėje. Dalyviai, kurie patyrė erdvių pakeitimus, turėjo didesnį laimės jausmą negu
ten kur tų intervencijų nebuvo. Jie jautė didesnį susidomėjimą tom vietom, taip pat
pasitikėjimą nepažįstamiems žmonėms.&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
    &lt;iframe src=&quot;https://player.vimeo.com/video/225338772&quot; width=&quot;640&quot; height=&quot;360&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">Šis klausimas įkvėpė “Happy City” įgyvendinti eksperimentą Vankuveryje (Kanada) kuris parodytų kaip spalvingos ir nekasdieninės intervencijos gali įtakoti žmonių gerbūvį. Pagrindinė eksperimento idėja buvo suprasti, kaip miesto dizainas gali veikti žmonių pasitikėjimo jausmą nepažįstamiems, jų emocijas. Eksperimento dalyviai praėjo per trys populiariausias vietas kuriomis kasdien keliauja miesto gyventojai - takas tarp gyvenamųjų namų, sankryžą, bei tvarkingą žaliąją erdvę. Dalyviai aplankė trys tas pačias vietas kur buvo atlikti pakeitimai.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/HappyStreets3-web.jpg" /></entry><entry><title type="html">Kaip projektuoti miestus socialiniams pokyčiams - trys principai</title><link href="https://urbanistas.lt/supratimas/2017/12/09/kaip-projektuoti-miestus-socialiniams-pokyciams.html" rel="alternate" type="text/html" title="Kaip projektuoti miestus socialiniams pokyčiams - trys principai" /><published>2017-12-09T08:10:00+00:00</published><updated>2017-12-09T08:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2017/12/09/kaip-projektuoti-miestus-socialiniams-pokyciams</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2017/12/09/kaip-projektuoti-miestus-socialiniams-pokyciams.html">&lt;p&gt;Tam, kad miestas ir miesto bendruomenės aktyviai ir produktyviai 
vystytųsi miestas turėtų būti pritaikytas socialiniams pokyčiams. Kartais - tai tiesiog erdvė kuri pritaikyta
protesto akcijoms arba mitingams. Pasaulio istorija ir įvykiai parodė, kad kartais tokios žmonių
iniciatyvos yra būtinos ir labai svarbios visuomenės raidai. Masuma Henry, buvusi vykdančioji konsultavimo ir UX (vartotojo potyrio)
agentūros &lt;a href=&quot;https://www.artefactgroup.com/&quot;&gt;Artefact&lt;/a&gt; direktorė, išskyrė trys pagrindinius principus,
kuriais būtina vadovautis projektuojant erdvę socialiniams pokyčiams.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Erdvė turi būti pritaikyta socialiniams pokyčiams&quot; src=&quot;/assets/social_changes_2-56cdfdaed6380fa90bccbfa75f19272cffdee41fe1c532ac9033d192a97ca530.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;
    Nuotrauka: MUSTAFA CAGLAYAN/ANADOLU AGENCY/GETTY IMAGES
&lt;/div&gt;

&lt;h2 id=&quot;delegavimas&quot;&gt;Delegavimas&lt;/h2&gt;

&lt;p&gt;Pati Henry vadina šį principą &lt;em&gt;agency&lt;/em&gt;: vartotojo, miestiečio tikėjimas, kad jis pats gali priimti sprendimą ir suprasti
ko jam reikia. Tie, kas projektuoja erdves turi klausti savęs ar jie suteikia laisvę žmogui dalyvauti ir
priimti sprendimus miesto erdvėse, neatsižvelgiant į jo socialinį statusą. Kitaip tariant - miestuose reikia statyti
ne tik namus ir įrenginėti aikštes, bet ir kurti empatijos tinklą.&lt;/p&gt;

&lt;h2 id=&quot;prieiga&quot;&gt;Prieiga&lt;/h2&gt;

&lt;p&gt;Prieiga - tai miestiečio galimybė lengvai ir patogiai naudotis galimybėmis, kurias suteikia erdvė.
Iš esmės, kalba eina apie meisto gyventojo potyrio projektavimą, kuris panaikina visus barjerus. Be abejo, 
kasdieniai rutininiai procesai gali būti nuobodus, bet būtent į jų projektavimą reikia sukoncentruoti didžiausią dėmesį.&lt;/p&gt;

&lt;h2 id=&quot;veiksmas&quot;&gt;Veiksmas&lt;/h2&gt;

&lt;p&gt;Galimybės ir patirtys negali įtakoti realų pakeitimą, jeigu miestietis neturi tikros galios priimti sprendimą -
 įvykdyti veiksmą. Tai yra ne taip paprasta, dizainas ir projektavimas veikimui - tai supratimas, kaip
žmonės mąsto ir elgėsi. Pasiekti tinkamą rezultatą galima testuojant hipotezes ir prototipavimu. 
Principai teisingo projektavimo buvo panaudoti kompanijoje &lt;a href=&quot;https://blacklivesmatter.com/&quot;&gt;“Black Lives Matter”&lt;/a&gt; kuri vyko visoje JAV.&lt;/p&gt;</content><author><name></name></author><summary type="html">Tam, kad miestas ir miesto bendruomenės aktyviai ir produktyviai vystytųsi miestas turėtų būti pritaikytas socialiniams pokyčiams. Kartais - tai tiesiog erdvė kuri pritaikyta protesto akcijoms arba mitingams. Pasaulio istorija ir įvykiai parodė, kad kartais tokios žmonių iniciatyvos yra būtinos ir labai svarbios visuomenės raidai. Masuma Henry, buvusi vykdančioji konsultavimo ir UX (vartotojo potyrio) agentūros Artefact direktorė, išskyrė trys pagrindinius principus, kuriais būtina vadovautis projektuojant erdvę socialiniams pokyčiams.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/social_changes_2.jpg" /></entry><entry><title type="html">Nematomi pėstieji 🚶</title><link href="https://urbanistas.lt/supratimas/2017/11/26/nematomi-pestieji.html" rel="alternate" type="text/html" title="Nematomi pėstieji 🚶" /><published>2017-11-26T08:10:00+00:00</published><updated>2017-11-26T08:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2017/11/26/nematomi-pestieji</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2017/11/26/nematomi-pestieji.html">&lt;p&gt;Kasmet Lietuvoje įvykių su partrentkais perėjose, kelkraščiuose žmonėmis nemažėja.
Valdžia bando pratinti gyventojus neišeiti iš namų be atšvaito, netgi tokiuose miestuose kaip Vilnius ir Kaunas
XXI amžiuje. Atrodo, kad problemos sprendimas turėtų būti šiek tiek kitoks, 
pradedant nuo saugios pėsčiųjų infrastrūkturos iki prevencinių priemonių greičiui mažinti mieste.
Pabandžiau išsiaiškinti, kodėl mūsų perėjose iki šiol žmonės yra nutrenkami ir žudomi kasdien?&lt;/p&gt;

&lt;h2 id=&quot;nereikalingi-elementai-ir-ryškios-spalvos&quot;&gt;Nereikalingi elementai ir ryškios spalvos&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&quot;Ryški ir neteisinga perėja mieste&quot; src=&quot;/assets/neteisinga-pereja-023264f61fadb9e4c3f2133625a1f6e950dcc392e2f639f15c87430a4427947a.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Ryškios spalvos atkreipia dėmesį nuo pesčiųjų&lt;/div&gt;

&lt;p&gt;Kažkodėl mūsų žmonėms atrodo, kad ryškus elementai ir detalės gali padėti apsaugojant pėstįjį perėjoje. 
Dažnai manoma, kad ženklai geltonam/žaliam fone, raudona zebra ar kiti elementai kurie išryškina perėja turi padėti vairuotojui
pastebėti pėstįjį.
Dėja, visi šitie elementai tik blaško vairuotojo dėmesį ir pagrindinis perėjos naudotojas tampa nematomu.&lt;/p&gt;

&lt;p&gt;Iš tiesu, taisyklinga perėja turi turėtų minimumą elementų (ypač spalvingų), tam kad vairuotojas galėtų pastebėti
pėstįjį, o ne ženklus ar nuspalvinta zebra.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Naktinė perėja&quot; src=&quot;/assets/pesciuju_pereja_nakti-2-245ddb0b9df39d36f0b73ddaac09733d9d4a36aa79d87043419c4c4c83ea4e13.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Pėsčiųjų perėja nakty&lt;/div&gt;

&lt;p&gt;Teisingai įrengta perėja turi apšviesti pėstįjį, o ne perėjos elementus.&lt;/p&gt;

&lt;h2 id=&quot;greitis-mieste&quot;&gt;Greitis mieste&lt;/h2&gt;

&lt;p&gt;Aš jau &lt;a href=&quot;/supratimas/2017/03/11/saugi-stotele.html&quot;&gt;rašiau&lt;/a&gt; apie butinybę mažinti greitį mieste - ribojant pagreitijimo zonas, įrenginėjant siauras gatves, 
mažinant eismo juostų kiekį. Pridursiu, kad greitis prieš perėja (nesvarbu koks yra leistinas greitis gatvėje)
neturi viršyti 20km/h. Kaip tai įgyvendinti? Pažymėti stop linijas, įrengti pagreitėjimui trukdančias priemones, siaurinti
pravažiavimą.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Gera perėja&quot; src=&quot;/assets/gera_pereja-2cb513f67e36b2f66969acc01ac2e8af7a8e6a9b7bbbadcd9757af7818992a61.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Perėja su ženklais virš zebros, Haga. Nuotrauka: varlamov.ru&lt;/div&gt;</content><author><name></name></author><summary type="html">Kasmet Lietuvoje įvykių su partrentkais perėjose, kelkraščiuose žmonėmis nemažėja. Valdžia bando pratinti gyventojus neišeiti iš namų be atšvaito, netgi tokiuose miestuose kaip Vilnius ir Kaunas XXI amžiuje. Atrodo, kad problemos sprendimas turėtų būti šiek tiek kitoks, pradedant nuo saugios pėsčiųjų infrastrūkturos iki prevencinių priemonių greičiui mažinti mieste. Pabandžiau išsiaiškinti, kodėl mūsų perėjose iki šiol žmonės yra nutrenkami ir žudomi kasdien?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/pesciuju_pereja_nakti-2.jpg" /></entry><entry><title type="html">Trys viename: traukiniai, tramvajai ir autobusai po vienu stogu Utrechto stotyje</title><link href="https://urbanistas.lt/erdves/2017/03/21/trys-viename-stotis-utrechte.html" rel="alternate" type="text/html" title="Trys viename: traukiniai, tramvajai ir autobusai po vienu stogu Utrechto stotyje" /><published>2017-03-21T08:10:00+00:00</published><updated>2017-03-21T08:10:00+00:00</updated><id>https://urbanistas.lt/erdves/2017/03/21/trys-viename-stotis-utrechte</id><content type="html" xml:base="https://urbanistas.lt/erdves/2017/03/21/trys-viename-stotis-utrechte.html">&lt;p&gt;Bendra olandų ir vokiečių architektūrinė studija &lt;a href=&quot;http://benthemcrouwel.com/&quot;&gt; Benthem Crouwel Architects &lt;/a&gt; specializuojasi stočių ir įvairių transporto architektūros projektų, pvz. jie suprojektavo &lt;a href=&quot;/dizainas/2016/11/23/cuyperspassage-pati-maloniausia-pozemine-pereja.html&quot;&gt;“pačią maloniausią požeminę perėją”&lt;/a&gt;.
Jų naujas projektas Utrechto mieste yra ypač įdomus - centrinėje stotyje dabar kartu “sugyvena” traukiniai, tramvajai ir kitas antžeminis transportas.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;/** DOMTokenList polyfill */

(function(){
	&quot;use strict&quot;;
	
	/*&lt;*/
	var UNDEF,
	WIN   = window,
	DOC   = document,
	OBJ   = Object,
	NULL  = null,
	TRUE  = true,
	FALSE = false,
	/*&gt;*/
	
	/** Munge the hell out of our string literals. Saves a tonne of space after compression. */
	SPACE           = &quot; &quot;,
	ELEMENT         = &quot;Element&quot;,
	CREATE_ELEMENT  = &quot;create&quot;+ELEMENT,
	DOM_TOKEN_LIST  = &quot;DOMTokenList&quot;,
	DEFINE_GETTER   = &quot;__defineGetter__&quot;,
	DEFINE_PROPERTY = &quot;defineProperty&quot;,
	CLASS_          = &quot;class&quot;,
	LIST            = &quot;List&quot;,
	CLASS_LIST      = CLASS_+LIST,
	REL             = &quot;rel&quot;,
	REL_LIST        = REL+LIST,
	DIV             = &quot;div&quot;,
	LENGTH          = &quot;length&quot;,
	CONTAINS        = &quot;contains&quot;,
	APPLY           = &quot;apply&quot;,
	HTML_           = &quot;HTML&quot;,
	METHODS         = (&quot;item &quot;+CONTAINS+&quot; add remove toggle toString toLocaleString&quot;).split(SPACE),
	ADD             = METHODS[2],
	REMOVE          = METHODS[3],
	TOGGLE          = METHODS[4],
	PROTOTYPE       = &quot;prototype&quot;,
	
	
	
	/** Ascertain browser support for Object.defineProperty */
	dpSupport       = DEFINE_PROPERTY in OBJ || DEFINE_GETTER in OBJ[ PROTOTYPE ] || NULL,
	
	
	/** Wrapper for Object.defineProperty that falls back to using the legacy __defineGetter__ method if available. */
	defineGetter    = function(object, name, fn, configurable){
		if(OBJ[ DEFINE_PROPERTY ])
			OBJ[ DEFINE_PROPERTY ](object, name, {
				configurable: FALSE === dpSupport ? TRUE : !!configurable,
				get:          fn
			});
		
		else object[ DEFINE_GETTER ](name, fn);
	},
	
	
	
	
	/** DOMTokenList interface replacement */
	DOMTokenList = function(el, prop){
		var THIS    = this,
		
		/** Private variables */
		tokens      = [],
		tokenMap    = {},
		length      = 0,
		maxLength   = 0,
		
		
		reindex     = function(){
			
			/** Define getter functions for array-like access to the tokenList's contents. */
			if(length &gt;= maxLength)
				for(; maxLength &lt; length; ++maxLength) (function(i){
					
					defineGetter(THIS, i, function(){
						preop();
						return tokens[i];
					}, FALSE);
					
				})(maxLength);
		},
		
		
		
		/** Helper function called at the start of each class method. Internal use only. */
		preop = function(){
			var error, i,
			args    = arguments,
			rSpace  = /\s+/;
			
			/** Validate the token/s passed to an instance method, if any. */
			if(args[ LENGTH ])
				for(i = 0; i &lt; args[ LENGTH ]; ++i)
					if(rSpace.test(args[i])){
						error       = new SyntaxError('String &quot;' + args[i] + '&quot; ' + CONTAINS + ' an invalid character');
						error.code  = 5;
						error.name  = &quot;InvalidCharacterError&quot;;
						throw error;
					}
			
			
			/** Split the new value apart by whitespace*/
			tokens = (&quot;&quot; + el[prop]).replace(/^\s+|\s+$/g, &quot;&quot;).split(rSpace);
			
			/** Avoid treating blank strings as single-item token lists */
			if(&quot;&quot; === tokens[0]) tokens = [];
			
			/** Repopulate the internal token lists */
			tokenMap = {};
			for(i = 0; i &lt; tokens[ LENGTH ]; ++i)
				tokenMap[tokens[i]] = TRUE;
			length = tokens[ LENGTH ];
			reindex();
		};
		
		
		
		/** Populate our internal token list if the targeted attribute of the subject element isn't empty. */
		preop();
		
		
		
		/** Return the number of tokens in the underlying string. Read-only. */
		defineGetter(THIS, LENGTH, function(){
			preop();
			return length;
		});
		
		
		/** Override the default toString/toLocaleString methods to return a space-delimited list of tokens when typecast. */
		THIS[ METHODS[6] /** toLocaleString */ ] =
		THIS[ METHODS[5] /** toString       */ ] = function(){
			preop();
			return tokens.join(SPACE);
		};
		
		
		
		/** Return an item in the list by its index (or undefined if the number is greater than or equal to the length of the list) */
		THIS.item = function(idx){
			preop();
			return tokens[idx];
		};
		
		
		/** Return TRUE if the underlying string contains `token`; otherwise, FALSE. */
		THIS[ CONTAINS ] = function(token){
			preop();
			return !!tokenMap[token];
		};
		
		
		
		/** Add one or more tokens to the underlying string. */
		THIS[ADD] = function(){
			preop[APPLY](THIS, args = arguments);

			for(var args, token, i = 0, l = args[ LENGTH ]; i &lt; l; ++i){
				token = args[i];
				if(!tokenMap[token]){
					tokens.push(token);
					tokenMap[token] = TRUE;
				}
			}
			
			/** Update the targeted attribute of the attached element if the token list's changed. */
			if(length  !== tokens[ LENGTH ]){
				length   = tokens[ LENGTH ] &gt;&gt;&gt; 0;
				el[prop] = tokens.join(SPACE);
				reindex();
			}
		};
		
		
		
		/** Remove one or more tokens from the underlying string. */
		THIS[ REMOVE ] = function(){
			preop[APPLY](THIS, args = arguments);
			
			/** Build a hash of token names to compare against when recollecting our token list. */
			for(var args, ignore = {}, i = 0, t = []; i &lt; args[ LENGTH ]; ++i){
				ignore[args[i]] = TRUE;
				delete tokenMap[args[i]];
			}
			
			/** Run through our tokens list and reassign only those that aren't defined in the hash declared above. */
			for(i = 0; i &lt; tokens[ LENGTH ]; ++i)
				if(!ignore[tokens[i]]) t.push(tokens[i]);
			
			tokens   = t;
			length   = t[ LENGTH ] &gt;&gt;&gt; 0;
			
			/** Update the targeted attribute of the attached element. */
			el[prop] = tokens.join(SPACE);
			reindex();
		};
		
		
		
		/** Add or remove a token depending on whether it's already contained within the token list. */
		THIS[TOGGLE] = function(token, force){
			preop[APPLY](THIS, [token]);
			
			/** Token state's being forced. */
			if(UNDEF !== force){
				if(force) { THIS[ADD](token);     return TRUE;  }
				else      { THIS[REMOVE](token);  return FALSE; }
			}
			
			/** Token already exists in tokenList. Remove it, and return FALSE. */
			if(tokenMap[token]){
				THIS[ REMOVE ](token);
				return FALSE;
			}
			
			/** Otherwise, add the token and return TRUE. */
			THIS[ADD](token);
			return TRUE;
		};
		
		
		/** Mark our newly-assigned methods as non-enumerable. */
		(function(o, defineProperty){
			if(defineProperty)
				for(var i = 0; i &lt; 7; ++i)
					defineProperty(o, METHODS[i], {enumerable: FALSE});
		}(THIS, OBJ[ DEFINE_PROPERTY ]));
		
		return THIS;
	},
	
	
	
	/** Polyfills a property with a DOMTokenList */
	addProp = function(o, name, attr){
		
		defineGetter(o[PROTOTYPE], name, function(){
			var tokenList,
			THIS = this,
			
			/** Prevent this from firing twice for some reason. What the hell, IE. */
			gibberishProperty           = DEFINE_GETTER + DEFINE_PROPERTY + name;
			if(THIS[gibberishProperty]) return tokenList;
			THIS[gibberishProperty]     = TRUE;
			
			
			/**
			 * IE8 can't define properties on native JavaScript objects, so we'll use a dumb hack instead.
			 *
			 * What this is doing is creating a dummy element (&quot;reflection&quot;) inside a detached phantom node (&quot;mirror&quot;)
			 * that serves as the target of Object.defineProperty instead. While we could simply use the subject HTML
			 * element instead, this would conflict with element types which use indexed properties (such as forms and
			 * select lists).
			 */
			if(FALSE === dpSupport){
				
				var visage,
				mirror      = addProp.mirror = addProp.mirror || DOC[ CREATE_ELEMENT ](DIV),
				reflections = mirror.childNodes,
				
				/** Iterator variables */
				l = reflections[ LENGTH ],
				i = 0;
				
				for(; i &lt; l; ++i)
					if(reflections[i]._R === THIS){
						visage = reflections[i];
						break;
					}
				
				/** Couldn't find an element's reflection inside the mirror. Materialise one. */
				visage || (visage = mirror.appendChild(DOC[ CREATE_ELEMENT ](DIV)));
				
				tokenList = DOMTokenList.call(visage, THIS, attr);
			}
			
			else tokenList = new DOMTokenList(THIS, attr);
			
			
			defineGetter(THIS, name, function(){ return tokenList; });
			delete THIS[gibberishProperty];
			
			return tokenList;
		}, TRUE);
	},

	/** Variables used for patching native methods that're partially implemented (IE doesn't support adding/removing multiple tokens, for instance). */
	testList,
	nativeAdd,
	nativeRemove;
	
	
	
	
	/** No discernible DOMTokenList support whatsoever. Time to remedy that. */
	if(!WIN[ DOM_TOKEN_LIST ]){
		
		/** Ensure the browser allows Object.defineProperty to be used on native JavaScript objects. */
		if(dpSupport)
			try{ defineGetter({}, &quot;support&quot;); }
			catch(e){ dpSupport = FALSE; }
		
		
		DOMTokenList.polyfill   = TRUE;
		WIN[ DOM_TOKEN_LIST ]   = DOMTokenList;
		
		addProp( WIN[ ELEMENT ], CLASS_LIST, CLASS_ + &quot;Name&quot;);      /* Element.classList */
		addProp( WIN[ HTML_+ &quot;Link&quot;   + ELEMENT ], REL_LIST, REL);  /* HTMLLinkElement.relList */
		addProp( WIN[ HTML_+ &quot;Anchor&quot; + ELEMENT ], REL_LIST, REL);  /* HTMLAnchorElement.relList */
		addProp( WIN[ HTML_+ &quot;Area&quot;   + ELEMENT ], REL_LIST, REL);  /* HTMLAreaElement.relList */
	}
	
	
	/**
	 * Possible support, but let's check for bugs.
	 *
	 * Where arbitrary values are needed for performing a test, previous variables
	 * are recycled to save space in the minified file.
	 */
	else{
		testList = DOC[ CREATE_ELEMENT ](DIV)[CLASS_LIST];
		
		/** We'll replace a &quot;string constant&quot; to hold a reference to DOMTokenList.prototype (filesize optimisation, yaddah-yaddah...) */
		PROTOTYPE = WIN[DOM_TOKEN_LIST][PROTOTYPE];
		
		
		/** Check if we can pass multiple arguments to add/remove. To save space, we'll just recycle a previous array of strings. */
		testList[ADD][APPLY](testList, METHODS);
		if(2 &gt; testList[LENGTH]){
			nativeAdd      = PROTOTYPE[ADD];
			nativeRemove   = PROTOTYPE[REMOVE];
			
			PROTOTYPE[ADD] = function(){
				for(var i = 0, args = arguments; i &lt; args[LENGTH]; ++i)
					nativeAdd.call(this, args[i]);
			};
			
			PROTOTYPE[REMOVE] = function(){
				for(var i = 0, args = arguments; i &lt; args[LENGTH]; ++i)
					nativeRemove.call(this, args[i]);
			};
		}
		
		
		/** Check if the &quot;force&quot; option of .toggle is supported. */
		if(testList[TOGGLE](LIST, FALSE))
			PROTOTYPE[TOGGLE] = function(token, force){
				var THIS = this;
				THIS[(force = UNDEF === force ? !THIS[CONTAINS](token) : force) ? ADD : REMOVE](token);
				return !!force;
			};
	}
}());

// Adapted from https://gist.github.com/paulirish/1579671 which derived from 
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller.
// Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavič, Darius Bacon

// MIT license

if (!Date.now)
    Date.now = function() { return new Date().getTime(); };

(function() {
    'use strict';
    
    var vendors = ['webkit', 'moz'];
    for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) {
        var vp = vendors[i];
        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];
        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame']
                                   || window[vp+'CancelRequestAnimationFrame']);
    }
    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
        || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
        var lastTime = 0;
        window.requestAnimationFrame = function(callback) {
            var now = Date.now();
            var nextTime = Math.max(lastTime + 16, now);
            return setTimeout(function() { callback(lastTime = nextTime); },
                              nextTime - now);
        };
        window.cancelAnimationFrame = clearTimeout;
    }
}());

// ChildNode.remove
(function () {
  &quot;use strict&quot;;

  if(!(&quot;remove&quot; in Element.prototype)){
  	Element.prototype.remove = function(){
  		if(this.parentNode) {
  			this.parentNode.removeChild(this);
      }
  	};
  }
})();

// *** gn *** //
var gn = (function (g) {

  // return gn
  return g;
})(window.gn || {});
// extend
// @require &quot;/src/gn/base.js&quot;

gn.extend = function () {
  var obj, name, copy,
  target = arguments[0] || {},
  i = 1,
  length = arguments.length;

  for (; i &lt; length; i++) {
    if ((obj = arguments[i]) !== null) {
      for (name in obj) {
        copy = obj[name];

        if (target === copy) {
          continue;
        } else if (copy !== undefined) {
          target[name] = copy;
        }
      }
    }
  }
  return target;
};
// isInViewport
// @require &quot;/src/gn/base.js&quot;

gn.isInViewport = function ( elem ) {
  var rect = elem.getBoundingClientRect();
  return (
    rect.bottom &gt; 0 &amp;&amp;
    rect.right &gt; 0 &amp;&amp;
    rect.top &lt; document.documentElement.clientHeight &amp;&amp;
    rect.left &lt; document.documentElement.clientWidth
    );
};
// indexOf
// @require &quot;/src/gn/base.js&quot;

gn.indexOf = function (array, item) {
  for (var i = 0; i &lt; array.length; i++) {
    if (array[i] === item) { return i; }
  }
  return -1;
};
// get supported property
// @require &quot;/src/gn/base.js&quot;

gn.getSupportedProp = function (proparray){
  var root = document.documentElement;
  for (var i=0; i&lt;proparray.length; i++){
    if (proparray[i] in root.style){
      return proparray[i];
    }
  }
};

// var getTD = gn.getSupportedProp(['transitionDuration', 'WebkitTransitionDuration', 'MozTransitionDuration', 'OTransitionDuration']),
// getTransform = gn.getSupportedProp(['transform', 'WebkitTransform', 'MozTransform', 'OTransform']);
// DOM ready
// @require &quot;/src/gn/base.js&quot;

gn.ready = function ( fn ) {

  // Sanity check
  if ( typeof fn !== 'function' ) { return; }

  // If document is already loaded, run method
  if ( document.readyState === 'complete'  ) {
    return fn();
  }

  // Otherwise, wait until document is loaded
  document.addEventListener( 'DOMContentLoaded', fn, false );
};
// isNodeList
// @require &quot;/src/gn/base.js&quot;

gn.isNodeList = function (el) {
  // Only NodeList has the &quot;item()&quot; function
  return typeof el.item !== 'undefined'; 
};

// append
// @require &quot;/src/gn/base.js&quot;
// @require &quot;/src/gn/isNodeList.js&quot;

gn.append = function(els, data) {
  var els_new = (gn.isNodeList(els)) ? els : [els], i;

  if (typeof data.nodeType !== &quot;undefined&quot; &amp;&amp; data.nodeType === 1) {
    for (i = els_new.length; i--;) {
      els_new[i].appendChild(data);
    }
  } else if (typeof data === &quot;string&quot;) {
    for (i = els_new.length; i--;) {
      els_new[i].insertAdjacentHTML('beforeend', data);
    }
  } else if (gn.isNodeList(data)) {
    var fragment = document.createDocumentFragment();
    for (i = data.length; i--;) {
      fragment.insertBefore(data[i], fragment.firstChild);
    }
    for (var j = els_new.length; j--;) {
      els_new[j].appendChild(fragment);
    }
  }
};


// wrap
// @require &quot;/src/gn/base.js&quot;
// @require &quot;/src/gn/isNodeList.js&quot;

gn.wrap = function (els, obj) {
    var elsNew = (gn.isNodeList(els)) ? els : [els];
  // Loops backwards to prevent having to clone the wrapper on the
  // first element (see `wrapper` below).
  for (var i = elsNew.length; i--;) {
      var wrapper = (i &gt; 0) ? obj.cloneNode(true) : obj,
          el = elsNew[i];

      // Cache the current parent and sibling.
      var parent = el.parentNode,
          sibling = el.nextSibling;

      // Wrap the element (is automatically removed from its current parent).
      wrapper.appendChild(el);

      // If the element had a sibling, insert the wrapper before
      // the sibling to maintain the HTML structure; otherwise, just
      // append it to the parent.
      if (sibling) {
          parent.insertBefore(wrapper, sibling);
      } else {
          parent.appendChild(wrapper);
      }
  }
};


// unwrap
// @require &quot;/src/gn/base.js&quot;
// @require &quot;/src/gn/isNodeList.js&quot;

gn.unwrap = function (els) {
  var elsNew = (gn.isNodeList(els)) ? els : [els];
  for (var i = elsNew.length; i--;) {
    var el = elsNew[i];

    // get the element's parent node
    var parent = el.parentNode;
    
    // move all children out of the element
    while (el.firstChild) { 
      parent.insertBefore(el.firstChild, el); 
    }
    
    // remove the empty element
    parent.removeChild(el);
  }
};
/**
  * tiny-slider
  * @version 0.6.5
  * @author William Lin
  * @license The MIT License (MIT)
  * @github https://github.com/ganlanyuan/tiny-slider/
  */

var tinySlider = (function () {
  'use strict';

  // get supported property, KEYs
  var TRANSITIONDURATION = gn.getSupportedProp([
        'transitionDuration', 
        'WebkitTransitionDuration', 
        'MozTransitionDuration', 
        'OTransitionDuration'
      ]),
      TRANSFORM = gn.getSupportedProp([
        'transform', 
        'WebkitTransform', 
        'MozTransform', 
        'OTransform'
      ]),
      TRANSITIONEND = whichTransitionEvent(),
      KEY = {
        ENTER: 13,
        SPACE: 32,
        PAGEUP: 33,
        PAGEDOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40
      };

  function core (options) {
    options = gn.extend({
      container: document.querySelector('.slider'),
      mode: 'carousel',
      direction: 'horizontal',
      items: 1,
      gutter: 0,
      gutterPosition: 'right',
      edgePadding: 0,
      fixedWidth: false,
      slideByPage: false,
      slideBy: 1,
      controls: true,
      controlsText: ['prev', 'next'],
      controlsContainer: false,
      nav: true,
      navContainer: false,
      arrowKeys: false,
      speed: 250,
      autoplay: false,
      autoplayTimeout: 5000,
      autoplayDirection: 'forward',
      autoplayText: ['start', 'stop'],
      loop: true,
      autoHeight: false,
      responsive: false,
      lazyload: false,
      touch: true,
      rewind: false
    }, options || {});

    // make sure slide container exists
    if (typeof options.container !== 'object' || options.container === null) {
      return {
        init: function () {},
        destory: function () {}
      }; 
    }

    // === define and set variables ===
    var mode = options.mode,
        direction = options.direction,
        items = options.items,
        slideContainer = options.container,
        slideWrapper = document.createElement('div'),
        slideItems = slideContainer.children,
        slideCount = slideItems.length,
        gutter = options.gutter,
        gutterPosition = (options.gutterPosition === 'right') ? 'margin-right' : 'margin-left',
        gapAdjust = (options.gutterPosition === 'left') ? gutter : 0,
        edgePadding = options.edgePadding,
        indexAdjust = (edgePadding) ? 1 : 0,
        fixedWidth = options.fixedWidth,
        controls = options.controls,
        controlsText = options.controlsText,
        controlsContainer = (!options.controlsContainer) ? false : options.controlsContainer,
        nav = options.nav,
        navContainer = (!options.navContainer) ? false : options.navContainer,
        arrowKeys = options.arrowKeys,
        speed = (!TRANSITIONDURATION) ? 0 : options.speed,
        autoplay = options.autoplay,
        autoplayTimeout = options.autoplayTimeout,
        autoplayDirection = (options.autoplayDirection === 'forward') ? 1 : -1,
        autoplayText = options.autoplayText,
        rewind = options.rewind,
        loop = (options.rewind) ? false : options.loop,
        autoHeight = options.autoHeight,
        responsive = (fixedWidth) ? false : options.responsive,
        slideByPage = options.slideByPage,
        slideBy = (slideByPage || options.slideBy === 'page') ? items : options.slideBy,
        lazyload = options.lazyload,
        touch = options.touch,

        slideId,
        slideWidth,
        cloneCount = (loop) ? Math.ceil(slideCount*1.5) : (edgePadding) ? 1 : 0,
        slideCountNew = slideCount + cloneCount * 2,
        prevButton,
        nextButton,
        allNavs,
        navCountVisible,
        navCountVisibleCached = slideCount,
        navClicked = -1,
        navCurrent = 0,
        navCurrentCached = 0,
        index = cloneCount,
        indexCached = index,
        indexMax,
        resizeTimer,
        vw,
        ticking = false;

    if (autoplay) {
      var autoplayTimer,
          autoplayButton,
          animating = false;
    }

    if (touch) {
      var startX = 0,
          startY = 0,
          translateXInit,
          distX,
          distY,
          touchStarted;
    }

    // get items, slideWidth, navCountVisible
    var getItems = (function () {
      if (!fixedWidth) {
        return function () {
          var itemsTem = options.items,
              ww = document.documentElement.clientWidth,
              bpKeys = (typeof responsive === 'object') ? Object.keys(responsive) : false;

          if (bpKeys) {
            for (var i = 0; i &lt; bpKeys.length; i++) {
              if (ww &gt;= bpKeys[i]) { itemsTem = responsive[bpKeys[i]]; }
            }
          }
          return Math.max(1, Math.min(slideCount, itemsTem));
        };

      } else {
        return function () { return Math.max(1, Math.min(slideCount, Math.floor(vw / fixedWidth))); };
      }
    })();

    var getSlideWidth = (function () {
      if (fixedWidth) {
        return function () { return fixedWidth + gutter; };
      } else if (navigator.appVersion.indexOf(&quot;MSIE 8&quot;) &gt; 0) {
        if (edgePadding) {
          return function () { return Math.round((vw - gutter - edgePadding * 2) / items); };
        } else {
          return function () { return Math.round((vw + gutter) / items); };
        }
      } else {
        if (edgePadding) {
          return function () { return (vw - gutter - edgePadding * 2) / items; };
        } else {
          return function () { return (vw + gutter) / items; };
        }
      }
    })();

    var getVisibleNavCount = (function () {
      if (options.navContainer) {
        return function () { return slideCount; };
      } else {
        return function () { return Math.ceil(slideCount / items); };
      }
    })();

    function wrapContainer() {
      slideWrapper.className = 'tiny-slider';
      gn.wrap(slideContainer, slideWrapper);
      vw = slideWrapper.clientWidth;
    }

    function getVariables() {
      items = getItems();
      indexMax = slideCountNew - items - indexAdjust;
      slideWidth = getSlideWidth();
      navCountVisible = getVisibleNavCount();
      slideBy = (slideByPage || options.slideBy === 'page') ? items : options.slideBy;
    }

    function containerInit() {
      var gap = - gapAdjust;
      if (edgePadding) {
        if (fixedWidth) {
          gap = getFixedWidthEdgePadding();
        } else {
          gap += edgePadding + gutter;
        }
      }
      slideContainer.classList.add('tiny-content', mode, direction);
      var size = 'width: ' + (slideWidth + 1) * slideCountNew + 'px; ',
          x = (-index * slideWidth),
          transforms = (TRANSFORM) ? TRANSFORM + ': translate3d(' + x + 'px, 0px, 0px)' : 'left: ' + x + 'px';
      slideContainer.style.cssText += size + transforms;
    }

    // for IE10
    function msInit() {
      if (navigator.msMaxTouchPoints) {
        slideWrapper.classList.add('ms-touch');
        slideWrapper.addEventListener('scroll', ie10Scroll, false);
      }
    }

    // add ids
    function addIds() {
      if (slideContainer.id === '') {
        slideContainer.id = slideId = _getSlideId();
      } else {
        slideId = slideContainer.id;
      }
      for (var x = 0; x &lt; slideCount; x++) {
        slideItems[x].id = slideId + 'item' + x;
      }
    }

    function slideItemsInit() {
      // clone slides
      if (loop || edgePadding) {
        var fragmentBefore = document.createDocumentFragment(), 
            fragmentAfter = document.createDocumentFragment();

        for (var j = cloneCount; j--;) {
          var num = j%slideCount,
              cloneFirst = slideItems[num].cloneNode(true),
              cloneLast = slideItems[slideCount - 1 - num].cloneNode(true);

          // remove id from cloned slides
          _removeAttrs(cloneFirst, 'id');
          _removeAttrs(cloneLast, 'id');

          fragmentBefore.insertBefore(cloneFirst, fragmentBefore.firstChild);
          fragmentAfter.appendChild(cloneLast);
        }

        slideContainer.appendChild(fragmentBefore);
        slideContainer.insertBefore(fragmentAfter, slideContainer.firstChild);

        slideItems = slideContainer.children;
      }
      _setAttrs(slideItems, {
        'style': 'width: ' + (slideWidth - gutter) + 'px; ' + gutterPosition + ': ' + gutter + 'px',
        'aria-hidden': 'true'
      });
    }

    function controlsInit() {
      if (controls) {
        if (!options.controlsContainer) {
          gn.append(slideWrapper, '&lt;div class=&quot;tiny-controls&quot; aria-label=&quot;Carousel Navigation&quot;&gt;&lt;button data-controls=&quot;prev&quot; tabindex=&quot;-1&quot; aria-controls=&quot;' + slideId +'&quot; type=&quot;button&quot;&gt;' + controlsText[0] + '&lt;/button&gt;&lt;button data-controls=&quot;next&quot; tabindex=&quot;0&quot; aria-controls=&quot;' + slideId +'&quot; type=&quot;button&quot;&gt;' + controlsText[1] + '&lt;/button&gt;&lt;/div&gt;');

          controlsContainer = slideWrapper.querySelector('.tiny-controls');
        }

        prevButton = controlsContainer.querySelector('[data-controls=&quot;prev&quot;]');
        nextButton = controlsContainer.querySelector('[data-controls=&quot;next&quot;]');

        if (!_hasAttr(controlsContainer, 'tabindex')) {
          _setAttrs(controlsContainer, {'aria-label': 'Carousel Navigation'});
          _setAttrs(controlsContainer.children, {
            'aria-controls': slideId,
            'tabindex': '-1',
          });
        }
      }
    }

    function navInit() {
      if (nav) {
        if (!options.navContainer) {
          var navHtml = '';
          for (var i = 0; i &lt; slideCount; i++) {
            navHtml += '&lt;button data-slide=&quot;' + i +'&quot; tabindex=&quot;-1&quot; aria-selected=&quot;false&quot; aria-controls=&quot;' + slideId + 'item' + i +'&quot; type=&quot;button&quot;&gt;&lt;/button&gt;';
          }
          if (autoplay) {
            navHtml += '&lt;button data-action=&quot;stop&quot; type=&quot;button&quot;&gt;&lt;span hidden&gt;Stop Animation&lt;/span&gt;' + autoplayText[0] + '&lt;/button&gt;';
          }
          navHtml = '&lt;div class=&quot;tiny-nav&quot; aria-label=&quot;Carousel Pagination&quot;&gt;' + navHtml + '&lt;/div&gt;';
          gn.append(slideWrapper, navHtml);
          navContainer = slideWrapper.querySelector('.tiny-nav');
        }
        allNavs = navContainer.querySelectorAll('[data-slide]');

        // for customized nav container
        if (!_hasAttr(navContainer, 'aria-label')) {
          _setAttrs(navContainer, {'aria-label': 'Carousel Pagination'});
          for (var y = 0; y &lt; slideCount; y++) {
            _setAttrs(allNavs[y], {
              'tabindex': '-1',
              'aria-selected': 'false',
              'aria-controls': slideId + 'item' + y,
            });
          }
        }

        for (var j = navCountVisible; j &lt; slideCount; j++) {
          _setAttrs(allNavs[j], {'hidden': ''});
        }
        navCountVisibleCached = navCountVisible;
      }
    }

    function autoplayInit() {
      if (autoplay) {
        if (!navContainer) {
          gn.append(slideWrapper, '&lt;div class=&quot;tiny-nav&quot; aria-label=&quot;Carousel Pagination&quot;&gt;&lt;button data-action=&quot;stop&quot; type=&quot;button&quot;&gt;&lt;span hidden&gt;Stop Animation&lt;/span&gt;' + autoplayText[0] + '&lt;/button&gt;&lt;/div&gt;');
          navContainer = slideWrapper.querySelector('.tiny-nav');
        }
        autoplayButton = navContainer.querySelector('[data-action]');
        startAction();
      }
    }

    function activateSlider() {
      for (var i = index; i &lt; index + items; i++) {
        _setAttrs(slideItems[i], {'aria-hidden': 'false'});
      }
      if (controls) {
        _setAttrs(nextButton, {'tabindex': '0'});
        if (index === indexAdjust &amp;&amp; !loop || rewind) {
          prevButton.disabled = true;
        }
      }
      if (nav) {
        _setAttrs(allNavs[0], {'tabindex': '0', 'aria-selected': 'true'});
      }
    }

    function addSliderEvents() {
      if (TRANSITIONEND) {
        slideContainer.addEventListener(TRANSITIONEND, onTransitionEnd, false);
      }
      if (touch) {
        slideContainer.addEventListener('touchstart', onPanStart, false);
        slideContainer.addEventListener('touchmove', onPanMove, false);
        slideContainer.addEventListener('touchend', onPanEnd, false);
        slideContainer.addEventListener('touchcancel', onPanEnd, false);
      }
      if (nav) {
        for (var y = 0; y &lt; slideCount; y++) {
          allNavs[y].addEventListener('click', onClickNav, false);
          allNavs[y].addEventListener('keydown', onKeyNav, false);
        }
      }
      if (controls) {
        prevButton.addEventListener('click', onClickControlPrev, false);
        nextButton.addEventListener('click', onClickControlNext, false);
        prevButton.addEventListener('keydown', onKeyControl, false);
        nextButton.addEventListener('keydown', onKeyControl, false);
      }
      if (autoplay) {
        autoplayButton.addEventListener('click', toggleAnimation, false);

        if (controls) {
          prevButton.addEventListener('click', stopAnimation, false );
          nextButton.addEventListener('click', stopAnimation, false );
        }

        if (nav) {
          for (var b = 0; b &lt; slideCount; b++) {
            allNavs[b].addEventListener('click', stopAnimation, false);
          }
        }
      }
      if (arrowKeys) {
        document.addEventListener('keydown', onKeyDocument, false);
      }
      window.addEventListener('resize', onResize, false);
      window.addEventListener('scroll', onScroll, false);
    }

    // lazyload
    function lazyLoad() {
      if (!lazyload || !gn.isInViewport(slideContainer)) { return; }

      var arr = [];
      for(var i = index - 1; i &lt; index + items + 1; i++) {
        var imgsTem = slideItems[i].querySelectorAll('.tiny-lazy');
        for(var j = imgsTem.length; j--; arr.unshift(imgsTem[j]));
        arr.unshift();
      }

      for (var h = arr.length; h--;) {
        var img = arr[h];
        if (!img.classList.contains('loaded')) {
          img.src = _getAttr(img, 'data-src');
          img.classList.add('loaded');
        }
      }
    }

    // check if all visible images are loaded
    // and update container height if it's done
    function runAutoHeight() {
      if (autoHeight) {
        // get all images inside visible slide items
        var images = [];

        for (var i = index -1; i &lt; index + items; i++) {
          var imagesTem = slideItems[i].querySelectorAll('img');
          for (var j = imagesTem.length; j--;) {
            images.push(imagesTem[j]);
          }
        }

        if (images.length === 0) {
          updateContainerHeight(); 
        } else {
          checkImagesLoaded(images);
        }
      }
    }

    function checkImagesLoaded(images) {
      for (var i = images.length; i--;) {
        if (imageLoaded(images[i])) {
          images.splice(i, 1);
        }
      }

      if (images.length === 0) {
        updateContainerHeight();
      } else {
        setTimeout(function () { 
          checkImagesLoaded(images); 
        }, 16);
      }
    } 

    function sliderInit() {
      wrapContainer();
      getVariables();

      containerInit();
      msInit();
      addIds();
      slideItemsInit();
      controlsInit();
      navInit();
      autoplayInit();
      activateSlider();
      addSliderEvents();
      checkSlideCount();

      lazyLoad();
      runAutoHeight();
    }

    function checkSlideCount() {
      if (slideCount &lt;= items) { 
        nav = controls = autoplay = loop = rewind = false; 
        index = cloneCount;

        if (navContainer) { _hideElement(navContainer); }
        if (controlsContainer) { _hideElement(controlsContainer); }
        if (autoplayButton) { _hideElement(autoplayButton); }
      } else {
        nav = options.nav;
        controls = options.controls;
        autoplay = options.autoplay;
        loop = (options.rewind) ? false : options.loop;
        rewind = options.rewind;

        if (nav) { _showElement(navContainer); }
        if (controls) { _showElement(controlsContainer); }
        if (autoplay) { _showElement(autoplayButton); }
      }
    }

    function getFixedWidthEdgePadding() {
      return ((vw - slideWidth * Math.floor(vw / slideWidth) + gutter) / 2);
    }

    var updateLayout = (function () {
      if (!fixedWidth) {
        return function () {
          // + 1: fixed half-pixel issue
          slideContainer.style.width = (slideWidth + 1) * slideCountNew + 'px'; 
          for (var i = slideCountNew; i--;) {
            slideItems[i].style.width = slideWidth - gutter + 'px';
          }
        };
      } else if (edgePadding) {
        return function () {
          slideContainer.style.marginLeft = getFixedWidthEdgePadding() + 'px';
        };
      }
    })();

    // update container height
    // 1. get the max-height of the visible slides
    // 2. set transitionDuration to speed
    // 3. update container height to max-height
    // 4. set transitionDuration to 0s after transition done
    function updateContainerHeight() {
      var heights = [], maxHeight;
      for (var i = index - indexAdjust; i &lt; index + items; i++) {
        heights.push(slideItems[i].offsetHeight);
      }
      maxHeight = Math.max.apply(null, heights);

      setTransitionDuration(1);
      slideContainer.style.height = maxHeight + 'px';
    }

    // set snapInterval (for IE10)
    function setSnapInterval() {
      slideWrapper.style.msScrollSnapPointsX = 'snapInterval(0%, ' + slideWidth + ')';
    }

    // update slide
    function updateSlideStatus() {
      var h1, h2, v1, v2;
      if (index !== indexCached) {
        if (index &gt; indexCached) {
          h1 = indexCached;
          h2 = Math.min(indexCached + items, index);
          v1 = Math.max(indexCached + items, index);
          v2 = index + items;
        } else {
          h1 = Math.max(index + items, indexCached);
          h2 = indexCached + items;
          v1 = index;
          v2 = Math.min(index + items, indexCached);
        }
      }
      indexCached = index;

      if (slideBy%1 !== 0) {
        h1 = Math.round(h1);
        h2 = Math.round(h2);
        v1 = Math.round(v1);
        v2 = Math.round(v2);
      }

      for (var i = h1; i &lt; h2; i++) {
        _setAttrs(slideItems[i], {'aria-hidden': 'true'});
      }
      for (var j = v1; j &lt; v2; j++) {
        _setAttrs(slideItems[j], {'aria-hidden': 'false'});
      }
    }

    // show or hide nav.
    // doesn't work on customized nav.
    function updateNavDisplay() {
      if (navCountVisible !== navCountVisibleCached) {
        if (navCountVisible &gt; navCountVisibleCached) {
          for (var i = navCountVisibleCached; i &lt; navCountVisible; i++) {
            _removeAttrs(allNavs[i], 'hidden');
          }
        } else {
          for (var j = navCountVisible; j &lt; navCountVisibleCached; j++) {
            _setAttrs(allNavs[j], {'hidden': ''});
          }
        }
      }
      navCountVisibleCached = navCountVisible;
    }

    // get current nav
    function getNavCurrent() {
      var navCurrentTem;
      if (navClicked === -1) {
        var absoluteIndex = (index &lt; cloneCount) ? index + slideCount : index%slideCount;
        if (options.navContainer) {
          return absoluteIndex;
        } else {
          navCurrentTem = Math.floor(absoluteIndex / items);
          // non-loop &amp; reach the edge
          if (!loop &amp;&amp; slideCount%items !== 0 &amp;&amp; index === slideCount - items) { navCurrentTem += 1; }
          return navCurrentTem;
        }
      } else {
        navCurrentTem = navClicked;
        navClicked = -1;
      }

      return navCurrentTem;
    }

    // set tabindex &amp; aria-selected on Nav
    function updateNavStatus() {
      if (nav) {
        if (navClicked === -1) {
          var absIndex = index;
          while (absIndex &lt; cloneCount) { absIndex += slideCount; }
          absIndex = (absIndex - cloneCount)%slideCount;
          if (options.navContainer) {
            navCurrent = absIndex;
          } else {
            navCurrent = Math.floor(absIndex / items);
            // non-loop &amp; reach the edge
            if (!loop &amp;&amp; slideCount%items !== 0 &amp;&amp; index === indexMax) { navCurrent += 1; }
          }
        } else {
          navCurrent = navClicked;
          navClicked = -1;
        }

        if (navCurrent !== navCurrentCached) {
          _setAttrs(allNavs[navCurrentCached], {
            'tabindex': '-1',
            'aria-selected': 'false'
          });

          _setAttrs(allNavs[navCurrent], {
            'tabindex': '0',
            'aria-selected': 'true'
          });
          navCurrentCached = navCurrent;
        }
      }
    }

    // set 'disabled' to true on controls when reach the edge
    function updateControlsStatus() {
      if (!controls || loop) { return; }
      if (index === indexAdjust || !rewind &amp;&amp; index === indexMax) {
        var inactive = (index === indexAdjust) ? prevButton : nextButton,
            active = (index === indexAdjust) ? nextButton : prevButton;

        changeFocus(inactive, active);

        inactive.disabled = true;
        _setAttrs(inactive, {'tabindex': '-1'});

        active.disabled = false;
        _setAttrs(active, {'tabindex': '0'});
      } else {
        prevButton.disabled = false;
        nextButton.disabled = false;
      }
    }

    // set transition duration
    var setTransitionDuration = (function () {
      if (TRANSITIONDURATION) { 
        return function (indexGap) {
          slideContainer.style[TRANSITIONDURATION] = (speed * indexGap / 1000) + 's';
        };
      } else {
        return function () {};
      }
    })();

    // make transfer after click/drag:
    // 1. change 'transform' property for mordern browsers
    // 2. change 'left' property for legacy browsers
    var transformCore = (function () {
      if (TRANSFORM) {
        return function (distance) {
          var x = distance || -slideWidth * index;
          slideContainer.style[TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';
        };
      } else {
        return function (distance) {
          var x = distance || -slideWidth * index;
          slideContainer.style.left = x + 'px';
        };
      }
    })();

    function doTransform (indexGap, distance) {
      if (TRANSITIONDURATION) { setTransitionDuration(indexGap); }
      transformCore(distance);
    }

    // check index after click/drag:
    // if there is not enough room for next transfering,
    // move slide container to a new location without animation
    // |-----|-----|----------|-----|-----|
    // |items|items|slideCount|items|items|
    function resetIndexAndContainer() {
      var leftEdge = slideBy + indexAdjust,
          rightEdge = slideCountNew - items - slideBy - 1; // -1: index starts form 0

      if (index &lt; leftEdge || index &gt; rightEdge) {
        (index - slideCount &gt;= leftEdge &amp;&amp; index - slideCount &lt;= rightEdge) ? index -= slideCount : index += slideCount;

        doTransform(0);
      }
    }

    function render(indexGap) {
      _setAttrs(slideContainer, {'aria-busy': 'true'});
      doTransform(indexGap);
      if (!TRANSITIONEND) { onTransitionEnd(); }
    }

    // AFTER TRANSFORM
    // Things need to be done after a transfer:
    // 1. check index
    // 2. add classes to visible slide
    // 3. disable controls buttons when reach the first/last slide in non-loop slider
    // 4. update nav status
    // 5. lazyload images
    // 6. update container height
    function onTransitionEnd(e) {
      if (!TRANSITIONEND || e.propertyName !== 'height') {
        if (loop) { resetIndexAndContainer(); }
        updateSlideStatus();
        updateNavStatus();
        updateControlsStatus();
        lazyLoad();
        runAutoHeight();
        _removeAttrs(slideContainer, 'aria-busy');
      }
    }

    // # ACTIONS
    // on controls click
    function onClickControl(dir) {
      if (_getAttr(slideContainer, 'aria-busy') !== 'true') {
        var indexTem = index + dir * slideBy,
            indexGap = Math.abs(dir * slideBy);
        index = (loop) ? indexTem : Math.max(indexAdjust, Math.min(indexTem, indexMax));

        render(indexGap);
      }
    }

    function onClickControlPrev() {
      onClickControl(-1);
    }

    function onClickControlNext() {
      if(rewind &amp;&amp; index === slideCount - items){
        onClickControl((items - slideCount) / slideBy);
      }else{
        onClickControl(1);
      }
    }

    // on doc click
    function onClickNav(e) {
      if (_getAttr(slideContainer, 'aria-busy') !== 'true') {
        var clickTarget = e.target || e.srcElement, navIndex, indexGap;

        while (gn.indexOf(allNavs, clickTarget) === -1) {
          clickTarget = clickTarget.parentNode;
        }

        navIndex = navClicked = Number(_getAttr(clickTarget, 'data-slide'));

        index = (options.navContainer) ? navIndex + cloneCount : navIndex * items + cloneCount;
        index = (loop) ? index : Math.min(index, indexMax);
        indexGap = Math.abs(index - indexCached);

        render(indexGap);
      }
    }

    function startAction() {
      autoplayTimer = setInterval(function () {
        onClickControl(autoplayDirection);
      }, autoplayTimeout);
      autoplayButton.setAttribute('data-action', 'stop');
      autoplayButton.innerHTML = '&lt;span hidden&gt;Stop Animation&lt;/span&gt;' + autoplayText[1];

      animating = true;
    }

    function stopAction() {
      clearInterval(autoplayTimer);
      autoplayButton.setAttribute('data-action', 'start');
      autoplayButton.innerHTML = '&lt;span hidden&gt;Stop Animation&lt;/span&gt;' + autoplayText[0];

      animating = false;
    }

    function toggleAnimation() {
      if (animating) {
        stopAction();
      } else {
        startAction();
      }
    }

    function stopAnimation() {
      if (animating) { stopAction(); }
    }

    // 
    function onKeyDocument(e) {
      e = e || window.event;
      if (e.keyCode === KEY.LEFT) {
        onClickControl(-1);
      } else if (e.keyCode === KEY.RIGHT) {
        if(rewind &amp;&amp; index === slideCount - items){
          onClickControl((items - slideCount) / slideBy);
        }else{
          onClickControl(1);
        }
      }
    }

    // change focus
    function changeFocus(blur, focus) {
      if (typeof blur === 'object' &amp;&amp; 
          typeof focus === 'object' &amp;&amp; 
          blur === document.activeElement) {
        blur.blur();
        focus.focus();
      }
    }

    // on key control
    function onKeyControl(e) {
      e = e || window.event;
      var code = e.keyCode,
          curElement = document.activeElement;

      switch (code) {
        case KEY.LEFT:
        case KEY.UP:
        case KEY.HOME:
        case KEY.PAGEUP:
          if (curElement !== prevButton &amp;&amp; prevButton.disabled !== true) {
            changeFocus(curElement, prevButton);
          }
          break;
        case KEY.RIGHT:
        case KEY.DOWN:
        case KEY.END:
        case KEY.PAGEDOWN:
          if (curElement !== nextButton &amp;&amp; nextButton.disabled !== true) {
            changeFocus(curElement, nextButton);
          }
          break;
        case KEY.ENTER:
        case KEY.SPACE:
          if (curElement === nextButton) {
            onClickControlNext();
          } else {
            onClickControlPrev();
          }
          break;
      }
    }

    // on key nav
    function onKeyNav(e) {
      e = e || window.event;
      var code = e.keyCode,
          curElement = document.activeElement,
          dataSlide = _getAttr(curElement, 'data-slide');

      switch(code) {
        case KEY.LEFT:
        case KEY.PAGEUP:
          if (dataSlide &gt; 0) { changeFocus(curElement, curElement.previousElementSibling); }
          break;
        case KEY.UP:
        case KEY.HOME:
          if (dataSlide !== 0) { changeFocus(curElement, allNavs[0]); }
          break;
        case KEY.RIGHT:
        case KEY.PAGEDOWN:
          if (dataSlide &lt; navCountVisible - 1) { changeFocus(curElement, curElement.nextElementSibling); }
          break;
        case KEY.DOWN:
        case KEY.END:
          if (dataSlide &lt; navCountVisible - 1) { changeFocus(curElement, allNavs[navCountVisible - 1]); }
          break;
        case KEY.ENTER:
        case KEY.SPACE:
          onClickNav(e);
          break;
      }
    }

    // IE10 scroll function
    function ie10Scroll() {
      doTransform(0, slideContainer.scrollLeft());
    }

    function onPanStart(e) {
      var touchObj = e.changedTouches[0];
      startX = parseInt(touchObj.clientX);
      startY = parseInt(touchObj.clientY);
      translateXInit = Number(slideContainer.style[TRANSFORM].slice(12, -13));
    }

    function onPanMove(e) {
      var touchObj = e.changedTouches[0];
      distX = parseInt(touchObj.clientX) - startX;
      distY = parseInt(touchObj.clientY) - startY;

      if (_getPanDirection(_toDegree(distY, distX), 15) === 'horizontal') { 
        touchStarted = true;
        e.preventDefault();
        doTransform(0, translateXInit + distX);
      }
    }

    function onPanEnd(e) {
      var touchObj = e.changedTouches[0];
      distX = parseInt(touchObj.clientX) - startX;

      if (touchStarted &amp;&amp; distX !== 0) {
        touchStarted = false;
        e.preventDefault();

        var indexTem = - (translateXInit + distX) / slideWidth;
        indexTem = (distX &gt; 0) ? Math.floor(indexTem) : Math.ceil(indexTem);
        index = Math.max(indexAdjust, Math.min(indexTem, indexMax));

        var translateXEnd = - index * slideWidth;
        if (!loop &amp;&amp; !edgePadding &amp;&amp; fixedWidth) {
          translateXEnd = Math.max(- (slideWidth * slideCount - vw), translateXEnd);
        }

        doTransform(1, translateXEnd);
        if (!TRANSITIONEND) { onTransitionEnd(); }
      }
    }

    // # RESIZE
    function onResize() {
      clearTimeout(resizeTimer);
      // update after stop resizing for 100 ms
      resizeTimer = setTimeout(function () {
        if (slideWrapper.clientWidth !== vw) {
          vw = slideWrapper.clientWidth;
          getVariables();
          checkSlideCount();

          updateLayout();
          updateNavDisplay();
          if (navigator.msMaxTouchPoints) { setSnapInterval(); }

          doTransform(0);
          if (!TRANSITIONEND) { onTransitionEnd(); }
        }
      }, 100);
    }

    function onScroll() {
      if (!ticking) {
        window.requestAnimationFrame(function() {
          lazyLoad();
          ticking = false;
        });
      }
      ticking = true;
    }

    return {
      init: sliderInit,

      // destory
      destory: function () {
        // slideWrapper
        gn.unwrap(slideWrapper);
        slideWrapper = null;

        // slideContainer
        slideContainer.classList.remove('tiny-content', mode, direction);
        _removeAttrs(slideContainer, ['id', 'style']);

        // cloned items
        if (loop) {
          for (var j = cloneCount; j--;) {
            slideItems[0].remove();
            slideItems[slideItems.length - 1].remove();
          }
        }

        // Slide Items
        _removeAttrs(slideItems, ['id', 'style', 'aria-hidden']);
        slideId = slideCount = null;

        // controls
        if (controls) {
          if (!options.controlsContainer) {
            controlsContainer.remove();
            controlsContainer = prevButton = nextButton = null;
          } else {
            _removeAttrs(controlsContainer, ['aria-label']);
            _removeAttrs(controlsContainer.children, ['aria-controls', 'tabindex']);
            _removeEvents(controlsContainer);
          }
        }

        // nav
        if (nav) {
          if (!options.navContainer) {
            navContainer.remove();
            navContainer = null;
          } else {
            _removeAttrs(navContainer, ['aria-label']);
            _removeAttrs(allNavs, ['aria-selected', 'aria-controls', 'tabindex']);
            _removeEvents(navContainer);
          }
          allNavs = null;
        }

        // auto
        if (autoplay) {
          if (!options.navContainer &amp;&amp; navContainer !== null) {
            navContainer.remove();
            navContainer = null;
          } else {
            _removeEvents(autoplayButton);
          }
        }

        // remove slider container events at the end
        // because this will make slideContainer = null
        _removeEvents(slideContainer);

        // remove arrowKeys eventlistener
        if (arrowKeys) {
          document.removeEventListener('keydown', onKeyDocument, false);
        }

        // remove window event listeners
        window.removeEventListener('resize', onResize, false);
        window.removeEventListener('scroll', onScroll, false);
      },

      getIndex: function () { return index; },
      // $ Private methods, for test only
      // hasAttr: _hasAttr, 
      // getAttr: _getAttr, 
      // setAttrs: _setAttrs, 
      // removeAttrs: _removeAttrs, 
      // removeEvents: _removeEvents, 
      // getSlideId: _getSlideId, 
      // toDegree: _toDegree, 
      // getPanDirection: _getPanDirection, 
      // hideElement: _hideElement, 
      // showElement: _showElement, 
      
      // mode: mode,
      // direction: direction,
      // gutter: gutter,
      // edgePadding: edgePadding,
      // fixedWidth: fixedWidth,
      // controls: controls,
      // nav: nav,
      // rewind: rewind,
      // loop: loop,
      // autoHeight: autoHeight,
      // slideBy: slideBy,
      // lazyload: lazyload,
      // touch: touch,
      // speed: speed,
      // items: getItems(),
      // cloneCount: cloneCount,
      // navCountVisible: function () { return navCountVisible; },
      // index: function () { return index; },
      // slideWidth: function () { return slideWidth; },
      
      // slideContainer: slideContainer,
      // slideItems: slideItems,
      // slideCount: slideCount,
      // controlsContainer: function () { return controlsContainer; },
      // prevButton: function () { return prevButton; }, 
      // nextButton: function () { return nextButton; }, 
      // navContainer: function () { return navContainer; },
      // allNavs: function () { return allNavs; },
    };
  }

  // === Private helper functions === //
  function _getSlideId() {
    if (window.tinySliderNumber === undefined) {
      window.tinySliderNumber = 1;
    } else {
      window.tinySliderNumber++;
    }
    return 'tinySlider' + window.tinySliderNumber;
  }

  function _toDegree (y, x) {
    return Math.atan2(y, x) * (180 / Math.PI);
  }

  function _getPanDirection(angle, range) {
    if ( Math.abs(90 - Math.abs(angle)) &gt;= (90 - range) ) {
      return 'horizontal';
    } else if ( Math.abs(90 - Math.abs(angle)) &lt;= range ) {
      return 'vertical';
    } else {
      return false;
    }
  }

  function _hasAttr(el, attr) {
    return el.hasAttribute(attr);
  }

  function _getAttr(el, attr) {
    return el.getAttribute(attr);
  }

  function _setAttrs(els, attrs) {
    els = (gn.isNodeList(els) || els instanceof Array) ? els : [els];
    if (Object.prototype.toString.call(attrs) !== '[object Object]') { return; }

    for (var i = els.length; i--;) {
      for(var key in attrs) {
        els[i].setAttribute(key, attrs[key]);
      }
    }
  }

  function _removeAttrs(els, attrs) {
    els = (gn.isNodeList(els) || els instanceof Array) ? els : [els];
    attrs = (attrs instanceof Array) ? attrs : [attrs];

    var attrLength = attrs.length;
    for (var i = els.length; i--;) {
      for (var j = attrLength; j--;) {
        els[i].removeAttribute(attrs[j]);
      }
    }
  }

  function _removeEvents(el) {
    var elClone = el.cloneNode(true), parent = el.parentNode;
    parent.insertBefore(elClone, el);
    el.remove();
    el = null;
  }

  function _hideElement(el) {
    if (!_hasAttr(el, 'hidden')) {
      _setAttrs(el, {'hidden': ''});
    }
  }

  function _showElement(el) {
    if (_hasAttr(el, 'hidden')) {
      _removeAttrs(el, 'hidden');
    }
  }

  // check if an image is loaded
  // 1. See if &quot;naturalWidth&quot; and &quot;naturalHeight&quot; properties are available.
  // 2. See if &quot;complete&quot; property is available.
  function imageLoaded(img) {
    if (typeof img.complete === 'boolean') {
      return img.complete;
    } else if (typeof img.naturalWidth === 'number') {
      return img.naturalWidth !== 0;
    }
  }

  // From Modernizr
  function whichTransitionEvent(){
    var t,
        el = document.createElement('fakeelement'),
        transitions = {
          'transition':'transitionend',
          'OTransition':'oTransitionEnd',
          'MozTransition':'transitionend',
          'WebkitTransition':'webkitTransitionEnd'
        };

    for(t in transitions){
      if( el.style[t] !== undefined ){
        return transitions[t];
      }
    }

    return false; // explicit for ie9-
  }

  return core;
})();
&lt;/script&gt;

&lt;div class=&quot;slider&quot;&gt;
    
        &lt;div&gt; &lt;img alt=&quot;Trys viename: traukiniai, tramvajai ir autobusai po vienu stogu Utrechto stotyje&quot; src=&quot;/assets/utrecht_station/4-7ccb5c78e3d5cbcabecac7ab0a21651bdc19e77848326b978b22c5f30a04b554.jpg&quot; /&gt; &lt;/div&gt;
    
        &lt;div&gt; &lt;img alt=&quot;Trys viename: traukiniai, tramvajai ir autobusai po vienu stogu Utrechto stotyje&quot; src=&quot;/assets/utrecht_station/5-965b871008ca218ff13c2cb3c97034774d61f1d10ca1bcef483b176686eb9c60.jpg&quot; /&gt; &lt;/div&gt;
    
        &lt;div&gt; &lt;img alt=&quot;Trys viename: traukiniai, tramvajai ir autobusai po vienu stogu Utrechto stotyje&quot; src=&quot;/assets/utrecht_station/6-95091e846b860bb969cc55417bfd398c68b0b4a1e842739165a1eb9c9fbccfc3.jpg&quot; /&gt; &lt;/div&gt;
    
        &lt;div&gt; &lt;img alt=&quot;Trys viename: traukiniai, tramvajai ir autobusai po vienu stogu Utrechto stotyje&quot; src=&quot;/assets/utrecht_station/13-60b20ceb6f8c814c76f180622c65d4c109f9341bb755fb2c8258806d222b02a8.jpg&quot; /&gt; &lt;/div&gt;
    
&lt;/div&gt;

&lt;script&gt;
gn.ready(function () {
  var slider = tinySlider({
    container: document.querySelector('.slider'),
    mode: 'carousel',
    direction: 'horizontal',
    items: 1,
    gutter: 0,
    // gutterPosition: 'right',
    edgePadding: 0,
    fixedWidth: false,
    //maxContainerWidth: true,
    //slideByPage: true,
    slideBy: 1,
    controls: true,
    controlsText: ['', ''],
    controlsContainer: document.querySelector('.slider-controls'),
    nav: true,
    navContainer: document.querySelector('.thumbnails'),
    arrowKeys: true,
    speed: 300,
    responsive: true,
    lazyload: true,
    touch: true,
    rewind: false
  });
  slider.init();
});
&lt;/script&gt;

&lt;div class=&quot;smaller lighter&quot; style=&quot;margin: 12px 0;&quot;&gt;
Nuotraukos: Jannes Linders
&lt;/div&gt;

&lt;p&gt;Pati įdomiausia šio projekto dalis tai šiuolaikiškai atrodantis bangos formos stogas. Jis ne tik atlieka estetinę funkciją, bet ir padeda keleiviams orientuotis stoties viduje.
Po pačiu didžiausiu stogo bangos keteru yra traukiniai, po mažesniu - tramvajai ir autobusai.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Stogas kaip navigacija&quot; src=&quot;/assets/utrecht_station/31-f47a22d2cb5a8fb767f539aacd8f5f24c51d6041da917303ce686e8805497bc3.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;smaller lighter&quot; style=&quot;margin: 12px 0;&quot;&gt;
Nuotrauka: Jannes Linders
&lt;/div&gt;

&lt;p&gt;Stoties projektą pradėjo kurti dar 2003 metais kai tapo aišku, jog senas pastatas negalėjo atlaikyti didėjančio keleivių srauto. Naujas pastatas didesnis seno beveik trys kartus ir jungia savyje ne tik skirtingas transporto rūšys, bet ir skirtingus transporto modelius ir logistikos tipus. Bangos formos stoties stoge yra liukai, kurie leidžia dienos šviesai papulti į vidų ir padeda ventiliuoti patalpas.&lt;/p&gt;</content><author><name></name></author><summary type="html">Bendra olandų ir vokiečių architektūrinė studija Benthem Crouwel Architects specializuojasi stočių ir įvairių transporto architektūros projektų, pvz. jie suprojektavo “pačią maloniausią požeminę perėją”. Jų naujas projektas Utrechto mieste yra ypač įdomus - centrinėje stotyje dabar kartu “sugyvena” traukiniai, tramvajai ir kitas antžeminis transportas.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/utrecht_station/31.jpg" /></entry><entry><title type="html">Kaip apsaugoti miestiečius nuo greito eismo pasekmių</title><link href="https://urbanistas.lt/supratimas/2017/03/11/saugi-stotele.html" rel="alternate" type="text/html" title="Kaip apsaugoti miestiečius nuo greito eismo pasekmių" /><published>2017-03-11T08:10:00+00:00</published><updated>2017-03-11T08:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2017/03/11/saugi-stotele</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2017/03/11/saugi-stotele.html">&lt;p&gt;Lėtas judėjimas mieste - viena iš saugiausių ir efektyviausių 
priemonių gelbėjanti daugybę gyvybių. Lėtai judėti automobilio 
vairuotoją gali priversti skirtingi būdai.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Kelias su kliutim&quot; src=&quot;/assets/movement/avarija-2-4bb209e4a5aa9f4481b7f61f2fa574a94e9bb564aa5b89abd4bb538c53e55a7e.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Sostinėje automobilis įlėkė į stotelę / Nuotrauka: &lt;a href=&quot;http://www.delfi.lt/news/daily/crime/sostineje-automobilis-ileke-i-stotele-suzalotuosius-gelbejo-vyriausybes-rumus-saugantys-pareigunai.d?id=69311086&quot;&gt;delfi.lt&lt;/a&gt;&lt;/div&gt;

&lt;h2 id=&quot;siauras-ir-vingiuotas-kelias&quot;&gt;Siauras ir vingiuotas kelias&lt;/h2&gt;

&lt;p&gt;Judant tiesiai visada galima pasigreitint ir paspausti akceleratoriaus pedalą, bet jeigu vairuotojui
teks važiuoti vingiuotu keliu - įsibėgėjimui nebeliks erdvės. Vairuotojas atidžiau vairuos ir mažins savo greitį.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Vingiuota gatvė&quot; src=&quot;/assets/movement/judejimas-1-cd2defbb47d5d63977b836f0b17ff12dcde6825c3484672c8aa64ad6a1679b1a.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Vingiuota gatvė&lt;/div&gt;

&lt;h2 id=&quot;saugumo-salelė&quot;&gt;Saugumo salelė&lt;/h2&gt;

&lt;p&gt;Saugumo salėlės taip pat padeda sumažinti eismo greitį.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Saugumo salelė&quot; src=&quot;/assets/movement/judejimas-3-ab66d9319c9844aada1fda13cce0f797cbd2286e251cf5195027260ea66d22c9.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Saugumo salelė Prahoje / Nuotrauka varlamov.ru&lt;/div&gt;

&lt;p&gt;Štai kaip turi atrodyti teisingas perėjimas.
&lt;img alt=&quot;Saugumo salelė&quot; src=&quot;/assets/movement/judejimas-4-d23b3e7425db009884ea6082ef58154194ac5612e94b6bb40daa89f85604fb2a.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Nuotrauka varlamov.ru&lt;/div&gt;

&lt;h2 id=&quot;gatvės-be-ženklų-ir-reguliavimo-shared-space&quot;&gt;Gatvės be ženklų ir reguliavimo (shared space)&lt;/h2&gt;
&lt;p&gt;Pasirodo gatvė kurioje nėra šaligatvio ir jos plotas dalinamas tarp visų eismo dalyvių yra vieną iš saugesniu.
Automobilio vairuotojas tampa atidesnis, kai nėra kelio ženklų ir juostų, jam tenka “bendrauti” su kitais eismo dalyviais (dviratininkais, pėsčiaisiais), 
padidėja vairuotojo atsakomybė.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Shared space&quot; src=&quot;/assets/movement/judejimas-2-3d2843344c0f863df231202a82fbc92b86a57f8c4528f0b5e39c47df1df8e945.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;video-container&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/8OwcS9Gvgmg&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">Lėtas judėjimas mieste - viena iš saugiausių ir efektyviausių priemonių gelbėjanti daugybę gyvybių. Lėtai judėti automobilio vairuotoją gali priversti skirtingi būdai.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/movement/avarija-2.jpg" /></entry><entry><title type="html">Vaikų žaidimo aikštelės</title><link href="https://urbanistas.lt/supratimas/2017/02/23/zaidimo-aiksteles.html" rel="alternate" type="text/html" title="Vaikų žaidimo aikštelės" /><published>2017-02-23T08:10:00+00:00</published><updated>2017-02-23T08:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2017/02/23/zaidimo-aiksteles</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2017/02/23/zaidimo-aiksteles.html">&lt;h2 id=&quot;-žaidimų-aikštelės-lietuvoje&quot;&gt;💩 žaidimų aikštelės Lietuvoje&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&quot;Žaidimų aikštelės Lietuvoje&quot; src=&quot;/assets/zaidimu_aiskteles/lietuvos-20015ac45e7b97c4b2bf3029b680a0319a12d2761bb3caecfd4bbee546d9a41f.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Lietuvos vaikams nepasisekė, jų kiemuose nėra įdomybių, erdvės užstatytos automobiliais ir spalvotais nameliais - kurie yra tik saugusiųjų iškraipyto supratimo
apie “teisingas” vaikų žaidimo aikšteles rezultatas. 
Yra ir išimčių, bet 90% vaikų žaidimų aikštelių tai kažkokie spalvoti ir mediniai namukai arba nuo tarybinių laikų likęs supuvęs metalas.&lt;/p&gt;

&lt;p&gt;Vaikų žaidimas  - tai gyvenimo pažinimas, žaidimo metu jis mokosi. Mažas žmogus mokosi būti savarankišku - bando priimti teisingus sprendimus, rizikuoti, laimėti ir pralaimėti, griūti ir atsistoti, bendrauti. Lietuvoje aikštelės sukurtos tam, kad suaugusieji jaustųsi ramiai, o ne vaikams - kurie nori pažinti šį pasaulį.&lt;/p&gt;

&lt;h2 id=&quot;-žaidimų-aikštelės-kitur&quot;&gt;🍬 žaidimų aikštelės kitur&lt;/h2&gt;

&lt;p&gt;Pažiūrėkime kokios yra vaikų aikštelės kitur.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Žaidimų aikštelė Londone&quot; src=&quot;/assets/zaidimu_aiskteles/london_1-ffda2e227f95c7e446bd6a75efa49140c2d337a6b8d35a86dd45296737b64d09.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Žaidimų aikštelė Londone / Nuotrauka: varlamov.ru&lt;/div&gt;

&lt;p&gt;&lt;img alt=&quot;Žaidimų aikštelė Londone&quot; src=&quot;/assets/zaidimu_aiskteles/london_2-9225f07432d27e655338dceafa1941c594576168617dc33fc2d0645f189ae060.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Žaidimų aikštelė Londone / Nuotrauka: varlamov.ru&lt;/div&gt;

&lt;p&gt;&lt;img alt=&quot;Žaidimų aikštelė Hamburge&quot; src=&quot;/assets/zaidimu_aiskteles/included-795f74d82364ea26bf7d54870b92e948983f1ebbe13b77e6b8e9a7de95c56e32.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:0 0 24px;&quot;&gt;Žaidimų aikštelė Hamburge / Nuotrauka: varlamov.ru&lt;/div&gt;

&lt;p&gt;Viena iš kiečiausių pasaulyje žaidimo aikštelių yra Sent Luise.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Žaidimų aikštelė Sent Luise&quot; src=&quot;/assets/zaidimu_aiskteles/stlouis-721fc243ab1b25e4ac0d08431adf730ef4335d538a22be7613f5ca061600ef7c.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;video-container&quot;&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/MyZHBp0IkUY&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">💩 žaidimų aikštelės Lietuvoje</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/zaidimu_aiskteles/london_2.jpg" /></entry><entry><title type="html">Pirmas totalitarinės valstybės požymis</title><link href="https://urbanistas.lt/supratimas/2017/02/16/pirmas-totalitarines-valstybes-pozymis.html" rel="alternate" type="text/html" title="Pirmas totalitarinės valstybės požymis" /><published>2017-02-16T17:10:00+00:00</published><updated>2017-02-16T17:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2017/02/16/pirmas-totalitarines-valstybes-pozymis</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2017/02/16/pirmas-totalitarines-valstybes-pozymis.html">&lt;p&gt;Nuotraukoje labai gerai matomas pirmas totalitarinės valstybės požymis - požeminė perėja.
Požeminė perėja netgi per siaurą gatvelę. Paslėpt žmones po žeme - 
mėgstamiausia tironų pramoga.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Šiaurės Korėja&quot; src=&quot;/assets/pozemine_pereja/north-korea-35121a17f22e9fcdfd4727cb772febb2979dbb018ff796f5f1966f8ada451ef0.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Pchenjanas, Šiaurės Korėja&lt;/div&gt;

&lt;p&gt;Kai kurie veidmainiai slepia savo tironiškas ambicijas už “pėsčiųjų saugumo rūpesčiu”.
Netgi kunigus pakviečia, kad tie “pašventintų” jų tironiškus sprendimus.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Valdžios tironija&quot; src=&quot;/assets/pozemine_pereja/pozemine-pereja-pil-f0652f3a650190ac51a98b078ee3ff07417a01e5d31dd7e709f5a967a50ace7d.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;O neįgaliems miesto gyventojams siūloma ieškoti laimės kitur.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Pilaitės perėja&quot; src=&quot;/assets/pozemine_pereja/pilaites-pereja-007b537e2de5468cd716adf436b902b2c861959f5a5fe6c0c507262d63a99ee0.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Jaunos mamos irgi įvertino visus požeminės perėjos siūlomus “patogumus”.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Pilaitės perėja - mamos&quot; src=&quot;/assets/pozemine_pereja/pozemine-pereja-3-04ba427a59f596f53b8dc5d9925f099cbc8cf7e82471db773a7e33f5374916ee.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Valstybės kurios rūpinasi savo gyventojais nebijo ilgų perėjų.
&lt;a href=&quot;/dizainas/2016/11/23/cuyperspassage-pati-maloniausia-pozemine-pereja.html&quot;&gt;Požemines perėjas&lt;/a&gt; daro
tik ten kur tai leidžia landšaftas.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Pedastrians&quot; src=&quot;/assets/pozemine_pereja/pedastrians-82749c9778f5c9b6bcc20b670a99be22963a987b62083c4696b77be8b32750dc.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Miestas ir jo erdvės turi priklausyti pėstiesiems, o požemines perėjas reikėtų užkasti.&lt;/p&gt;</content><author><name></name></author><summary type="html">Nuotraukoje labai gerai matomas pirmas totalitarinės valstybės požymis - požeminė perėja. Požeminė perėja netgi per siaurą gatvelę. Paslėpt žmones po žeme - mėgstamiausia tironų pramoga.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/pozemine_pereja/pozemine-pereja-pil.jpg" /></entry><entry><title type="html">Kaip judėti mieste?</title><link href="https://urbanistas.lt/supratimas/2017/02/14/judejimas-mieste.html" rel="alternate" type="text/html" title="Kaip judėti mieste?" /><published>2017-02-14T23:10:00+00:00</published><updated>2017-02-14T23:10:00+00:00</updated><id>https://urbanistas.lt/supratimas/2017/02/14/judejimas-mieste</id><content type="html" xml:base="https://urbanistas.lt/supratimas/2017/02/14/judejimas-mieste.html">&lt;p&gt;&lt;b&gt;Gyvenime mes visi norime greitai ir be streso pasiekti norimą tikslą. Tai labai panašu su mūsų judėjimu mieste. Kažkodėl mūsų kultūroje daugumą nori pasodinti savo &lt;span class=&quot;underline&quot;&gt;nutukusį kuną&lt;/span&gt; gražiąją sielą į nuosavą skardinę ir retai pagalvoja (o gal išvis to nedaro) apie judėjimo mieste alternatyvas, o jų yra daug.&lt;/b&gt;&lt;/p&gt;

&lt;h2 id=&quot;viešasis-transportas&quot;&gt;Viešasis transportas&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&quot;Viesasis transportas&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;float: right;margin-left: 24px;&quot; src=&quot;/assets/trulikas_vektor-f607a4f050f886f40e7e4d58f74cc0472d0cdc7d2533da04f3f7a5fd2076d533.svg&quot; /&gt;
Viešasis transportas yra pats populiariausias būdas judėti mieste, na gal tik judėjimas pėsčiomis arba dviračiu lenkia jį pagal populiarumą. Daugumą miestiečių renkasi jį kaip pagrindinį judėjimo mieste būdą. Pažiurėkime kokie yra pagrindiniai jo pliusai.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Dažniausiai viešasis transportas juda per jam skirtas juostas, tai padeda  miestiečiui nestovėti kamsčiuose ir laiku pasiekti norimą punktą. Miestuose kur vyksta judėjimas tramvajumi arba metro pasisekė labiau, jų transportas beveik nepriklauso nuo kamščiu ir susidariusių greičio lėtinimo aplinkybių mieste.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Šiuolaikinis viešasis transportas yra greitą, patogį, modernį ir atitinkantį miesto gyvenimo tempo transporto priemonė.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Viešojo transporto naudojimas nėra brangus, taikomos įvairios nuolaidos priklausomai nuo amžiaus, socialinio statuso, kai kur, pvz. Taline, jis yra nemokamas.
Palyginus su automobilio išlaikymu kaštais kai kuriose šalyse tai ženklus sanaudų skirtumas.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dėja, vilniečiams ne taip pasisekė kaip Zalcburgo ar Bergeno gyventojams, kol kas jie neturi galimybės pilnai džiaugtis ir išnaudoti visus šiuolaikinio viešojo transporto siūlomus privalumus.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Troleibusas Vilniuje&quot; src=&quot;/assets/trulikas-e74ddd029b05838ee801eaa6500571a08c7f0f9bb2e7ed3d7aa3858fd9850a42.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Vilniaus troleibusas&lt;/div&gt;

&lt;h2 id=&quot;automobilio-dalijimosi-paslaugos-car-sharing&quot;&gt;Automobilio dalijimosi paslaugos (car sharing)&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&quot;Automobilio dalijimosi paslauga&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;float: right;margin-left: 24px;&quot; src=&quot;/assets/car_sharing-f2ae07f8a603d0f4b199cb2ae00be86cd471eef725e1b341464fe551f48b233f.svg&quot; /&gt;
Didžiuose šiuolaikiniuose miestuose veikia automobilio dalijimosi sistemos. Tai labai patogus būdas išsinuomoti automobilį (dažniausiai trumpalaikiai nuomai).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Car sharing’o automobiliai dažniausiai buna varomi elektra arba hybridai, tai padeda sumažinti ekologinią taršą miestui ir automobilio išlaikymo kaštus - ko pasekoje klientas moka pigiau už paslaugą.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Automobilių parkavimas yra nemokamas, miestas suinteresuotas suteikti tai, nes automobilis efektyviau naudojamas - didžiąją laiko dalį važiuoja, o ne stovi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Automobilio dalijimosi kompanija pasirupins viskuo - technine apžiūra, draudimu, kuru ir švara - jums tereikės kurui pasibaigant sustoti ir užsipilti jį degalinėje, bet už tai kompanija dažniausiai taiko nuolaidą kelionėi.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img alt=&quot;Spark automobiliai&quot; src=&quot;/assets/spark_auto-e0f0477904e476eabd1b6b4e7a5a8c8bd462e8eb25a1f776af655e89ee293168.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Spark automobiliai&lt;/div&gt;

&lt;h2 id=&quot;taksi&quot;&gt;Taksi&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&quot;Taksi paslaugos&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;float: right;margin-left: 24px;&quot; src=&quot;/assets/taxi-092c0d4bf7c87310ee2f58d5a520955ee104765d2f19915ac36b2b689a4349fe.svg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Taksi kasmet tampa vis populiaresniu judėjimo būdų mieste, didelė rinka ir konkurencija joje leidžia naudotis patogiu judėjimu būdu už nedidelę kainą. Yra daugybę įmonių teikiančių taksi paslaugas, bet mes aptarstime dvi patogiausiais tai TAXIFY ir Uber. Iš esmės jie yra labai panašus, tik tiek, kad TAXIFY turi tiek nuosavų automobilių vairuotojus, tiek taksi įmonių.&lt;/p&gt;

&lt;h2 id=&quot;dviratis&quot;&gt;Dviratis&lt;/h2&gt;

&lt;p&gt;Vienas iš greičiausių ir maloniausių būdų judėti mieste. Dviratis padeda ne tik greitai nuvažiuoti iš taško A į B, bet taip pat ir palaikyti gerą fizinę formą. Vilniuje veikia puiki dviračio nuomos sistema “Cyclocity”, dviračio kaina vienam sezonui (balandis - lapkritis) kainuoja 19.90 €, jeigu jums dar nesukako 27 metų - 13.90 €, 30 dienų nuoma kainuoja  3.90 €.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Oranžiniai dviračiai&quot; src=&quot;/assets/orand.dvirat-c1cbd36552e7929262cc665d91592e0aeef1c564090cc5eef1bc253c30b22771.jpg&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;lighter smaller&quot; style=&quot;margin:12px 0;&quot;&gt;Oranžiniai dviračiai /
Nuotrauka Cyclocity&lt;/div&gt;</content><author><name></name></author><summary type="html">Gyvenime mes visi norime greitai ir be streso pasiekti norimą tikslą. Tai labai panašu su mūsų judėjimu mieste. Kažkodėl mūsų kultūroje daugumą nori pasodinti savo nutukusį kuną gražiąją sielą į nuosavą skardinę ir retai pagalvoja (o gal išvis to nedaro) apie judėjimo mieste alternatyvas, o jų yra daug.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://urbanistas.lt/konstitucijos-stotele.jpg" /></entry></feed>